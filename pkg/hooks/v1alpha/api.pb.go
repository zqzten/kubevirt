// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

/*
Package v1alpha is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	InfoParams
	InfoResult
	OnDefineDomainParams
	OnDefineDomainResult
*/
package v1alpha

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type InfoParams struct {
	// supportedVersions is a list of versions supported by client
	SupportedVersions []string `protobuf:"bytes,1,rep,name=supportedVersions" json:"supportedVersions,omitempty"`
}

func (m *InfoParams) Reset()                    { *m = InfoParams{} }
func (m *InfoParams) String() string            { return proto.CompactTextString(m) }
func (*InfoParams) ProtoMessage()               {}
func (*InfoParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *InfoParams) GetSupportedVersions() []string {
	if m != nil {
		return m.SupportedVersions
	}
	return nil
}

type InfoResult struct {
	// name of the hook used by virt-launcher to compare it with requested hooks
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// priority is used to sort hooks prior to their execution (second key is the name)
	Priority uint32 `protobuf:"varint,2,opt,name=priority" json:"priority,omitempty"`
	// hookPoints is a list of subscribed hook points
	HookPoints []string `protobuf:"bytes,3,rep,name=hookPoints" json:"hookPoints,omitempty"`
	// version is choosen from passed supportedVersions, this version will be used for communication
	Version string `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
}

func (m *InfoResult) Reset()                    { *m = InfoResult{} }
func (m *InfoResult) String() string            { return proto.CompactTextString(m) }
func (*InfoResult) ProtoMessage()               {}
func (*InfoResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *InfoResult) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InfoResult) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *InfoResult) GetHookPoints() []string {
	if m != nil {
		return m.HookPoints
	}
	return nil
}

func (m *InfoResult) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type OnDefineDomainParams struct {
	// domainXML is original libvirt domain specification, it is XML passed as string
	DomainXML string `protobuf:"bytes,1,opt,name=domainXML" json:"domainXML,omitempty"`
	// vm is VirtualMachine is object of virtual machine currently processed by virt-launcher, it is encoded as JSON and passed as string
	Vm string `protobuf:"bytes,2,opt,name=vm" json:"vm,omitempty"`
}

func (m *OnDefineDomainParams) Reset()                    { *m = OnDefineDomainParams{} }
func (m *OnDefineDomainParams) String() string            { return proto.CompactTextString(m) }
func (*OnDefineDomainParams) ProtoMessage()               {}
func (*OnDefineDomainParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *OnDefineDomainParams) GetDomainXML() string {
	if m != nil {
		return m.DomainXML
	}
	return ""
}

func (m *OnDefineDomainParams) GetVm() string {
	if m != nil {
		return m.Vm
	}
	return ""
}

type OnDefineDomainResult struct {
	// domainXML is processed libvirt domain specification, it is XML passed as string
	DomainXML string `protobuf:"bytes,1,opt,name=domainXML" json:"domainXML,omitempty"`
}

func (m *OnDefineDomainResult) Reset()                    { *m = OnDefineDomainResult{} }
func (m *OnDefineDomainResult) String() string            { return proto.CompactTextString(m) }
func (*OnDefineDomainResult) ProtoMessage()               {}
func (*OnDefineDomainResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *OnDefineDomainResult) GetDomainXML() string {
	if m != nil {
		return m.DomainXML
	}
	return ""
}

func init() {
	proto.RegisterType((*InfoParams)(nil), "kubevirt.hooks.v1alpha.InfoParams")
	proto.RegisterType((*InfoResult)(nil), "kubevirt.hooks.v1alpha.InfoResult")
	proto.RegisterType((*OnDefineDomainParams)(nil), "kubevirt.hooks.v1alpha.OnDefineDomainParams")
	proto.RegisterType((*OnDefineDomainResult)(nil), "kubevirt.hooks.v1alpha.OnDefineDomainResult")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Hook service

type HookClient interface {
	Info(ctx context.Context, in *InfoParams, opts ...grpc.CallOption) (*InfoResult, error)
	OnDefineDomain(ctx context.Context, in *OnDefineDomainParams, opts ...grpc.CallOption) (*OnDefineDomainResult, error)
}

type hookClient struct {
	cc *grpc.ClientConn
}

func NewHookClient(cc *grpc.ClientConn) HookClient {
	return &hookClient{cc}
}

func (c *hookClient) Info(ctx context.Context, in *InfoParams, opts ...grpc.CallOption) (*InfoResult, error) {
	out := new(InfoResult)
	err := grpc.Invoke(ctx, "/kubevirt.hooks.v1alpha.Hook/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hookClient) OnDefineDomain(ctx context.Context, in *OnDefineDomainParams, opts ...grpc.CallOption) (*OnDefineDomainResult, error) {
	out := new(OnDefineDomainResult)
	err := grpc.Invoke(ctx, "/kubevirt.hooks.v1alpha.Hook/OnDefineDomain", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Hook service

type HookServer interface {
	Info(context.Context, *InfoParams) (*InfoResult, error)
	OnDefineDomain(context.Context, *OnDefineDomainParams) (*OnDefineDomainResult, error)
}

func RegisterHookServer(s *grpc.Server, srv HookServer) {
	s.RegisterService(&_Hook_serviceDesc, srv)
}

func _Hook_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HookServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubevirt.hooks.v1alpha.Hook/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HookServer).Info(ctx, req.(*InfoParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hook_OnDefineDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnDefineDomainParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HookServer).OnDefineDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubevirt.hooks.v1alpha.Hook/OnDefineDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HookServer).OnDefineDomain(ctx, req.(*OnDefineDomainParams))
	}
	return interceptor(ctx, in, info, handler)
}

var _Hook_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kubevirt.hooks.v1alpha.Hook",
	HandlerType: (*HookServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _Hook_Info_Handler,
		},
		{
			MethodName: "OnDefineDomain",
			Handler:    _Hook_OnDefineDomain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 282 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0xc9, 0x6a, 0xf3, 0x30,
	0x10, 0xc6, 0x89, 0xf9, 0xff, 0x7a, 0xa0, 0x81, 0x0e, 0xa5, 0x88, 0x50, 0x8a, 0xf1, 0xc9, 0x87,
	0x60, 0xe8, 0x72, 0xea, 0xd9, 0x87, 0x16, 0xba, 0x04, 0x1f, 0x4a, 0xaf, 0x0a, 0x51, 0x88, 0xb0,
	0xad, 0x11, 0x92, 0x2c, 0xe8, 0xfb, 0xf5, 0xc1, 0x4a, 0x64, 0xb7, 0xe9, 0x92, 0x86, 0xde, 0xf4,
	0x8d, 0x66, 0xbe, 0x65, 0x18, 0x48, 0xb8, 0x96, 0x85, 0x36, 0xe4, 0x08, 0x4f, 0xea, 0x6e, 0x21,
	0xbc, 0x34, 0xae, 0x58, 0x13, 0xd5, 0xb6, 0xf0, 0xe7, 0xbc, 0xd1, 0x6b, 0x9e, 0x5d, 0x03, 0xdc,
	0xaa, 0x15, 0xcd, 0xb9, 0xe1, 0xad, 0xc5, 0x19, 0x1c, 0xd9, 0x4e, 0x6b, 0x32, 0x4e, 0x2c, 0x9f,
	0x84, 0xb1, 0x92, 0x94, 0x65, 0x51, 0x3a, 0xce, 0x93, 0xea, 0xe7, 0x47, 0xe6, 0xfb, 0xd9, 0x4a,
	0xd8, 0xae, 0x71, 0x88, 0x10, 0x2b, 0xde, 0x0a, 0x16, 0xa5, 0x51, 0x9e, 0x54, 0xe1, 0x8d, 0x53,
	0x38, 0xd0, 0x46, 0x92, 0x91, 0xee, 0x85, 0x8d, 0xd2, 0x28, 0x3f, 0xac, 0x3e, 0x30, 0x9e, 0x01,
	0x6c, 0xac, 0xcc, 0x49, 0x2a, 0x67, 0xd9, 0x38, 0x88, 0x7c, 0xaa, 0x20, 0x83, 0xff, 0xbe, 0x57,
	0x62, 0x71, 0xa0, 0x7c, 0x87, 0x59, 0x09, 0xc7, 0x8f, 0xaa, 0x14, 0x2b, 0xa9, 0x44, 0x49, 0x2d,
	0x97, 0x6a, 0x70, 0x7f, 0x0a, 0xc9, 0x32, 0xe0, 0xe7, 0xfb, 0xbb, 0xc1, 0xc6, 0xb6, 0x80, 0x13,
	0x18, 0xf9, 0x36, 0xb8, 0x48, 0xaa, 0x91, 0x6f, 0xb3, 0xab, 0xef, 0x2c, 0x43, 0x8e, 0xbd, 0x2c,
	0x17, 0xaf, 0x11, 0xc4, 0x37, 0x44, 0x35, 0x3e, 0x40, 0xbc, 0x09, 0x8f, 0x59, 0xb1, 0x7b, 0xb3,
	0xc5, 0x76, 0xad, 0xd3, 0xbd, 0x3d, 0x83, 0x6c, 0x03, 0x93, 0xaf, 0x76, 0x70, 0xf6, 0xdb, 0xd4,
	0xae, 0xf0, 0xd3, 0x3f, 0x76, 0xf7, 0x6a, 0x8b, 0x7f, 0xe1, 0x2a, 0x2e, 0xdf, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x7b, 0x74, 0xe7, 0x62, 0x22, 0x02, 0x00, 0x00,
}
